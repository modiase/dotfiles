"""Core CVE scanning logic using NVD API."""

import asyncio
import time
from dataclasses import dataclass, field
from datetime import datetime, timezone
from urllib.parse import quote

import aiohttp
from loguru import logger

NVD_API = "https://services.nvd.nist.gov/rest/json/cves/2.0"


@dataclass
class CVE:
    """Represents a CVE finding."""

    id: str
    score: float
    description: str
    product: str


@dataclass
class RateLimiter:
    """Token bucket rate limiter."""

    tokens_per_period: int
    period_seconds: float
    tokens: float = field(init=False)
    last_update: float = field(init=False)

    def __post_init__(self):
        self.tokens = float(self.tokens_per_period)
        self.last_update = time.monotonic()

    async def acquire(self) -> None:
        """Acquire a token, waiting if necessary."""
        while True:
            now = time.monotonic()
            elapsed = now - self.last_update
            self.tokens = min(
                self.tokens_per_period,
                self.tokens + elapsed * (self.tokens_per_period / self.period_seconds),
            )
            self.last_update = now

            if self.tokens >= 1.0:
                self.tokens -= 1.0
                logger.debug(f"Token acquired, {self.tokens:.1f} remaining")
                return

            wait_time = (1.0 - self.tokens) * (
                self.period_seconds / self.tokens_per_period
            )
            logger.debug(f"Rate limited, waiting {wait_time:.2f}s for token")
            await asyncio.sleep(wait_time)


def create_rate_limiter(has_api_key: bool) -> RateLimiter:
    """Create rate limiter based on API key presence."""
    if has_api_key:
        logger.info("Using NVD API key (50 req/30s limit)")
        return RateLimiter(tokens_per_period=50, period_seconds=30)
    logger.info("No API key (5 req/30s limit)")
    return RateLimiter(tokens_per_period=5, period_seconds=30)


async def query_nvd(
    session: aiohttp.ClientSession,
    product: str,
    last_check: str,
    api_key: str | None,
    rate_limiter: RateLimiter,
) -> dict:
    """Query NVD API with rate limiting and exponential backoff."""
    encoded_product = quote(product, safe="")
    now = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.000")
    url = f"{NVD_API}?keywordSearch={encoded_product}&pubStartDate={last_check}&pubEndDate={now}"

    headers = {"Accept": "application/json"}
    if api_key:
        headers["apiKey"] = api_key

    logger.debug(f"Request URL: {url}")

    max_retries = 5
    base_delay = 1.0

    for attempt in range(max_retries):
        await rate_limiter.acquire()

        try:
            async with session.get(url, headers=headers) as resp:
                logger.debug(f"Response status for {product}: {resp.status}")
                if resp.status == 200:
                    data = await resp.json()
                    vuln_count = len(data.get("vulnerabilities", []))
                    logger.debug(f"Found {vuln_count} vulnerabilities for {product}")
                    return data
                elif resp.status == 403:
                    logger.warning(f"Rate limited for {product}, backing off...")
                elif resp.status >= 500:
                    logger.warning(
                        f"Server error {resp.status} for {product}, retrying..."
                    )
                else:
                    body = await resp.text()
                    logger.error(
                        f"Unexpected status {resp.status} for {product}: {body[:200]}"
                    )
                    return {}
        except aiohttp.ClientError as e:
            logger.warning(f"Request error for {product}: {e}")

        delay = base_delay * (2**attempt) + (asyncio.get_event_loop().time() % 1)
        logger.info(f"Retry {attempt + 1}/{max_retries} in {delay:.1f}s")
        await asyncio.sleep(delay)

    logger.error(f"Failed to query NVD for {product} after {max_retries} retries")
    return {}


def extract_cves(data: dict, cvss_threshold: float, product: str) -> list[CVE]:
    """Extract CVEs with CVSS >= threshold."""
    results = []

    for vuln in data.get("vulnerabilities", []):
        cve = vuln.get("cve", {})
        metrics = cve.get("metrics", {})

        score = None
        for metric_key in ["cvssMetricV31", "cvssMetricV30"]:
            metric_list = metrics.get(metric_key, [])
            if metric_list:
                score = metric_list[0].get("cvssData", {}).get("baseScore")
                if score:
                    break

        cve_id = cve.get("id")
        if score and score >= cvss_threshold:
            descriptions = cve.get("descriptions", [])
            description = descriptions[0].get("value", "") if descriptions else ""
            results.append(
                CVE(id=cve_id, score=score, description=description, product=product)
            )
            logger.debug(f"Critical CVE found: {cve_id} (CVSS {score})")
        elif score:
            logger.debug(f"CVE {cve_id} below threshold (CVSS {score})")

    return results


async def scan_product(
    session: aiohttp.ClientSession,
    product: str,
    last_check: str,
    api_key: str | None,
    rate_limiter: RateLimiter,
    cvss_threshold: float,
) -> list[CVE]:
    """Scan a single product and return CVEs above threshold."""
    logger.info(f"Querying NVD for: {product}")
    data = await query_nvd(session, product, last_check, api_key, rate_limiter)
    return extract_cves(data, cvss_threshold, product)


async def scan_products(
    products: list[str],
    last_check: str,
    api_key: str | None,
    cvss_threshold: float = 9.0,
) -> list[CVE]:
    """Scan multiple products concurrently."""
    rate_limiter = create_rate_limiter(has_api_key=bool(api_key))
    all_cves = []

    async with aiohttp.ClientSession() as session:
        tasks = [
            scan_product(
                session, product, last_check, api_key, rate_limiter, cvss_threshold
            )
            for product in products
        ]
        results = await asyncio.gather(*tasks)
        for cves in results:
            all_cves.extend(cves)

    return all_cves
