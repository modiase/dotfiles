"""Notification backends for CVE alerts."""

import html
import smtplib
from abc import ABC, abstractmethod
from base64 import urlsafe_b64encode
from dataclasses import dataclass
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from importlib import resources
from pathlib import Path
from typing import Final, Generic, TypeVar

import aiohttp
from google.cloud import pubsub_v1
from loguru import logger

from .scanner import CVE

HTTP_TIMEOUT: Final = aiohttp.ClientTimeout(total=30, connect=10)
SMTP_TIMEOUT: Final = 30

OptionsT = TypeVar("OptionsT")


@dataclass(frozen=True)
class NtfyOptions:
    title: str = ""
    priority: int = 3
    tags: str = ""


@dataclass(frozen=True)
class EmailOptions:
    subject: str = ""


def _load_template(name: str) -> str:
    static = resources.files(__package__).joinpath("static")
    return Path(str(static.joinpath(name))).read_text()


def format_cve_email(cves: list[CVE]) -> str:
    email_template = _load_template("email.html")
    row_template = _load_template("email_row.html")

    rows = []
    for cve in cves:
        escaped_id = html.escape(cve.id)
        escaped_product = html.escape(cve.product)
        escaped_desc = html.escape(cve.description)
        short_desc = (
            escaped_desc[:150] + "..." if len(escaped_desc) > 150 else escaped_desc
        )
        systems_str = ", ".join(sorted(cve.systems)) if cve.systems else "-"
        rows.append(
            row_template.format(
                id=escaped_id,
                score=cve.score,
                product=escaped_product,
                systems=html.escape(systems_str),
                description=short_desc,
            )
        )

    return email_template.format(count=len(cves), rows="".join(rows))


class Notifier(ABC, Generic[OptionsT]):
    """Abstract base class for notification backends."""

    @abstractmethod
    async def notify(self, message: str, options: OptionsT | None = None) -> bool:
        """Send a simple notification message."""
        ...

    @abstractmethod
    async def send(self, cves: list[CVE], *, dry_run: bool = False) -> bool:
        """Send notifications for CVEs. Returns True on success."""
        ...

    async def send_raw(
        self, subject: str, html_content: str, *, dry_run: bool = False
    ) -> bool:
        """Send raw HTML content. Override if supported."""
        del subject, html_content, dry_run
        logger.error(f"{self.__class__.__name__} does not support raw content")
        return False

    async def test_credentials(self) -> bool:
        """Test that credentials are valid. Override if supported."""
        logger.warning(f"{self.__class__.__name__} does not support credential testing")
        return True


class NtfyNotifier(Notifier[NtfyOptions]):
    """Send notifications via Pub/Sub to ntfy-forwarder."""

    def __init__(self, topic: str, project_id: str = "modiase-infra"):
        self.topic = topic
        self.project_id = project_id
        self._publisher = pubsub_v1.PublisherClient()
        self._topic_path = self._publisher.topic_path(project_id, "ntfy")

    async def notify(self, message: str, options: NtfyOptions | None = None) -> bool:
        opts = options or NtfyOptions()
        attributes = {
            "topic": self.topic,
            "priority": str(opts.priority),
            "markdown": "yes",
        }
        if opts.title:
            attributes["title"] = opts.title
        if opts.tags:
            attributes["tags"] = opts.tags

        try:
            future = self._publisher.publish(
                self._topic_path, message.encode(), **attributes
            )
            future.result(timeout=30)
            logger.info(f"Sent ntfy via Pub/Sub: {opts.title or message[:50]}")
            return True
        except Exception:
            logger.exception("Pub/Sub publish failed")
            return False

    def _format_message(self, cve: CVE) -> str:
        return f"""**Product**: {cve.product}
**CVSS**: {cve.score}
**CVE**: [{cve.id}](https://nvd.nist.gov/vuln/detail/{cve.id})"""

    async def send(self, cves: list[CVE], *, dry_run: bool = False) -> bool:
        if not cves:
            logger.debug("No CVEs to notify")
            return True

        if dry_run:
            logger.info(f"[DRY RUN] Would send {len(cves)} ntfy notifications")
            for cve in cves:
                logger.info(f"[DRY RUN] --- {cve.id} ---")
                print(self._format_message(cve))
            return True

        success = True
        for cve in cves:
            opts = NtfyOptions(
                title=f"Critical CVE: {cve.id}", priority=5, tags="warning"
            )
            if not await self.notify(self._format_message(cve), opts):
                success = False
        return success


class EmailNotifier(Notifier[EmailOptions]):
    """Send notifications via SMTP."""

    def __init__(
        self,
        *,
        smtp_host: str,
        smtp_port: int,
        user: str,
        password: str,
        from_addr: str,
        to_addr: str,
    ):
        self.smtp_host = smtp_host
        self.smtp_port = smtp_port
        self.user = user
        self.password = password
        self.from_addr = from_addr
        self.to_addr = to_addr

    async def notify(self, message: str, options: EmailOptions | None = None) -> bool:
        opts = options or EmailOptions()
        subject = opts.subject or "Notification"
        return await self._send_email(subject, message, f"<p>{message}</p>")

    async def test_credentials(self) -> bool:
        """Test SMTP connection and login."""
        try:
            with smtplib.SMTP(
                self.smtp_host, self.smtp_port, timeout=SMTP_TIMEOUT
            ) as server:
                server.starttls()
                server.login(self.user, self.password)
            logger.info(f"SMTP credentials valid for {self.smtp_host}")
            return True
        except (smtplib.SMTPException, TimeoutError):
            logger.exception("SMTP credential test failed")
            return False

    async def send(self, cves: list[CVE], *, dry_run: bool = False) -> bool:
        if not cves:
            logger.debug("No CVEs to notify")
            return True

        cve_list = "\n".join(f"- {c.id} (CVSS {c.score}) - {c.product}" for c in cves)
        text_body = (
            f"Critical CVE Alert\n\nFound {len(cves)} critical CVE(s):\n\n{cve_list}"
        )
        html_body = format_cve_email(cves)
        subject = f"Critical CVE Alert: {len(cves)} vulnerabilities found"

        return await self._send_email(subject, text_body, html_body, dry_run=dry_run)

    async def send_raw(
        self, subject: str, html_content: str, *, dry_run: bool = False
    ) -> bool:
        text_body = "View in HTML-capable email client."
        return await self._send_email(subject, text_body, html_content, dry_run=dry_run)

    async def _send_email(
        self, subject: str, text_body: str, html_body: str, *, dry_run: bool = False
    ) -> bool:
        if dry_run:
            logger.info("[DRY RUN] Testing SMTP credentials...")
            if not await self.test_credentials():
                return False
            logger.info(f"[DRY RUN] Would send email to {self.to_addr}")
            logger.info(f"[DRY RUN] Subject: {subject}")
            logger.info("[DRY RUN] --- HTML Body ---")
            print(html_body)
            return True

        msg = MIMEMultipart("alternative")
        msg["Subject"] = subject
        msg["From"] = self.from_addr
        msg["To"] = self.to_addr

        msg.attach(MIMEText(text_body, "plain"))
        msg.attach(MIMEText(html_body, "html"))

        try:
            with smtplib.SMTP(
                self.smtp_host, self.smtp_port, timeout=SMTP_TIMEOUT
            ) as server:
                server.starttls()
                server.login(self.user, self.password)
                server.sendmail(self.from_addr, [self.to_addr], msg.as_string())
            logger.info(f"Sent email to {self.to_addr}")
            return True
        except (smtplib.SMTPException, TimeoutError):
            logger.exception("Failed to send email")
            return False


class GmailNotifier(Notifier[EmailOptions]):
    """Send notifications via Gmail API with OAuth2."""

    def __init__(
        self,
        client_id: str,
        client_secret: str,
        refresh_token: str,
        address: str,
        from_name: str = "CVE Scanner",
    ):
        self.client_id = client_id
        self.client_secret = client_secret
        self.refresh_token = refresh_token
        self.address = address
        self.from_name = from_name

    async def notify(self, message: str, options: EmailOptions | None = None) -> bool:
        opts = options or EmailOptions()
        subject = opts.subject or "Notification"
        async with aiohttp.ClientSession(timeout=HTTP_TIMEOUT) as session:
            return await self._send_via_api(session, subject, f"<p>{message}</p>")

    async def _get_access_token(self, session: aiohttp.ClientSession) -> str | None:
        """Get access token using refresh token."""
        try:
            async with session.post(
                "https://oauth2.googleapis.com/token",
                data={
                    "client_id": self.client_id,
                    "client_secret": self.client_secret,
                    "refresh_token": self.refresh_token,
                    "grant_type": "refresh_token",
                },
            ) as resp:
                data = await resp.json()
                if "access_token" in data:
                    return data["access_token"]
                logger.error(f"Failed to get access token: {data}")
                return None
        except aiohttp.ClientError:
            logger.exception("OAuth token request failed")
            return None

    async def test_credentials(self) -> bool:
        """Test OAuth2 token exchange."""
        async with aiohttp.ClientSession(timeout=HTTP_TIMEOUT) as session:
            token = await self._get_access_token(session)
            if token:
                logger.info("Gmail OAuth2 credentials valid")
                return True
            return False

    def _create_raw_email(self, subject: str, html_content: str) -> str:
        """Create base64url-encoded email for Gmail API."""
        msg = MIMEMultipart("alternative")
        msg["From"] = f'"{self.from_name}" <{self.address}>'
        msg["To"] = self.address
        msg["Subject"] = subject

        msg.attach(MIMEText("View in HTML-capable email client.", "plain"))
        msg.attach(MIMEText(html_content, "html"))

        raw = msg.as_bytes()
        return urlsafe_b64encode(raw).decode().rstrip("=")

    async def _send_via_api(
        self,
        session: aiohttp.ClientSession,
        subject: str,
        html_content: str,
        *,
        dry_run: bool = False,
    ) -> bool:
        """Send email via Gmail API."""
        access_token = await self._get_access_token(session)
        if not access_token:
            return False

        if dry_run:
            logger.info("[DRY RUN] Gmail OAuth2 credentials valid")
            logger.info(f"[DRY RUN] Would send email to {self.address}")
            logger.info(f"[DRY RUN] Subject: {subject}")
            logger.info("[DRY RUN] --- HTML Body ---")
            print(html_content)
            return True

        raw_email = self._create_raw_email(subject, html_content)

        try:
            async with session.post(
                "https://gmail.googleapis.com/gmail/v1/users/me/messages/send",
                headers={
                    "Authorization": f"Bearer {access_token}",
                    "Content-Type": "application/json",
                },
                json={"raw": raw_email},
            ) as resp:
                data = await resp.json()
                if "id" in data:
                    logger.info(f"Email sent via Gmail API: {data['id']}")
                    return True
                logger.error(f"Gmail API error: {data}")
                return False
        except aiohttp.ClientError:
            logger.exception("Gmail API request failed")
            return False

    async def send(self, cves: list[CVE], *, dry_run: bool = False) -> bool:
        if not cves:
            logger.debug("No CVEs to notify")
            return True

        subject = f"Critical CVE Alert: {len(cves)} vulnerabilities found"
        html_content = format_cve_email(cves)

        async with aiohttp.ClientSession(timeout=HTTP_TIMEOUT) as session:
            return await self._send_via_api(
                session, subject, html_content, dry_run=dry_run
            )

    async def send_raw(
        self, subject: str, html_content: str, *, dry_run: bool = False
    ) -> bool:
        async with aiohttp.ClientSession(timeout=HTTP_TIMEOUT) as session:
            return await self._send_via_api(
                session, subject, html_content, dry_run=dry_run
            )
