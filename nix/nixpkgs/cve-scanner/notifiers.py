"""Notification backends for CVE alerts."""

import smtplib
from abc import ABC, abstractmethod
from base64 import b64encode, urlsafe_b64encode
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

import aiohttp
from loguru import logger

from .scanner import CVE


class Notifier(ABC):
    """Abstract base class for notification backends."""

    @abstractmethod
    async def send(self, cves: list[CVE], *, dry_run: bool = False) -> bool:
        """Send notifications for CVEs. Returns True on success."""
        ...

    async def send_raw(
        self, subject: str, html_content: str, *, dry_run: bool = False
    ) -> bool:
        """Send raw HTML content. Override if supported."""
        logger.error(f"{self.__class__.__name__} does not support raw content")
        return False

    async def test_credentials(self) -> bool:
        """Test that credentials are valid. Override if supported."""
        logger.warning(f"{self.__class__.__name__} does not support credential testing")
        return True


class NtfyNotifier(Notifier):
    """Send notifications via ntfy."""

    def __init__(self, url: str, topic: str, auth: str | None = None):
        self.url = url.rstrip("/")
        self.topic = topic
        self.auth = auth

    def _format_message(self, cve: CVE) -> str:
        return f"""**Product**: {cve.product}
**CVSS**: {cve.score}
**CVE**: [{cve.id}](https://nvd.nist.gov/vuln/detail/{cve.id})"""

    async def send(self, cves: list[CVE], *, dry_run: bool = False) -> bool:
        if not cves:
            logger.debug("No CVEs to notify")
            return True

        if dry_run:
            logger.info(f"[DRY RUN] Would send {len(cves)} ntfy notifications")
            logger.info(f"[DRY RUN] URL: {self.url}/{self.topic}")
            for cve in cves:
                logger.info(f"[DRY RUN] --- {cve.id} ---")
                print(self._format_message(cve))
                print()
            return True

        success = True
        async with aiohttp.ClientSession() as session:
            for cve in cves:
                headers = {
                    "Title": f"Critical CVE: {cve.id}",
                    "Priority": "5",
                    "Tags": "warning",
                    "Markdown": "yes",
                }

                if self.auth:
                    if ":" in self.auth:
                        encoded = b64encode(self.auth.encode()).decode()
                        headers["Authorization"] = f"Basic {encoded}"
                    else:
                        headers["Authorization"] = f"Bearer {self.auth}"

                url = f"{self.url}/{self.topic}"
                message = self._format_message(cve)

                try:
                    async with session.post(
                        url, data=message.encode(), headers=headers
                    ) as resp:
                        if resp.status == 200:
                            logger.info(f"Sent ntfy alert for {cve.id}")
                        else:
                            body = await resp.text()
                            logger.error(
                                f"ntfy error {resp.status} for {cve.id}: {body[:200]}"
                            )
                            success = False
                except aiohttp.ClientError as e:
                    logger.error(f"ntfy request failed for {cve.id}: {e}")
                    success = False

        return success


class EmailNotifier(Notifier):
    """Send notifications via SMTP."""

    def __init__(
        self,
        smtp_host: str,
        smtp_port: int,
        user: str,
        password: str,
        from_addr: str,
        to_addr: str,
    ):
        self.smtp_host = smtp_host
        self.smtp_port = smtp_port
        self.user = user
        self.password = password
        self.from_addr = from_addr
        self.to_addr = to_addr

    def _format_html(self, cves: list[CVE]) -> str:
        rows = []
        for cve in cves:
            short_desc = cve.description[:150]
            if len(cve.description) > 150:
                short_desc += "..."
            rows.append(f"""
<tr>
    <td><a href="https://nvd.nist.gov/vuln/detail/{cve.id}">{cve.id}</a></td>
    <td>{cve.score}</td>
    <td>{cve.product}</td>
    <td>{short_desc}</td>
</tr>""")

        return f"""
<html>
<body>
<h2>Critical CVE Alert</h2>
<p>Found {len(cves)} critical CVE(s) matching your watchlist:</p>
<table border="1" cellpadding="5">
<tr><th>CVE</th><th>CVSS</th><th>Product</th><th>Description</th></tr>
{"".join(rows)}
</table>
</body>
</html>"""

    async def test_credentials(self) -> bool:
        """Test SMTP connection and login."""
        try:
            with smtplib.SMTP(self.smtp_host, self.smtp_port) as server:
                server.starttls()
                server.login(self.user, self.password)
            logger.info(f"SMTP credentials valid for {self.smtp_host}")
            return True
        except smtplib.SMTPException as e:
            logger.error(f"SMTP credential test failed: {e}")
            return False

    async def send(self, cves: list[CVE], *, dry_run: bool = False) -> bool:
        if not cves:
            logger.debug("No CVEs to notify")
            return True

        cve_list = "\n".join(f"- {c.id} (CVSS {c.score}) - {c.product}" for c in cves)
        text_body = (
            f"Critical CVE Alert\n\nFound {len(cves)} critical CVE(s):\n\n{cve_list}"
        )
        html_body = self._format_html(cves)
        subject = f"Critical CVE Alert: {len(cves)} vulnerabilities found"

        return await self._send_email(subject, text_body, html_body, dry_run=dry_run)

    async def send_raw(
        self, subject: str, html_content: str, *, dry_run: bool = False
    ) -> bool:
        text_body = "View in HTML-capable email client."
        return await self._send_email(subject, text_body, html_content, dry_run=dry_run)

    async def _send_email(
        self, subject: str, text_body: str, html_body: str, *, dry_run: bool = False
    ) -> bool:
        if dry_run:
            logger.info("[DRY RUN] Testing SMTP credentials...")
            if not await self.test_credentials():
                return False
            logger.info(f"[DRY RUN] Would send email to {self.to_addr}")
            logger.info(f"[DRY RUN] Subject: {subject}")
            logger.info("[DRY RUN] --- HTML Body ---")
            print(html_body)
            return True

        msg = MIMEMultipart("alternative")
        msg["Subject"] = subject
        msg["From"] = self.from_addr
        msg["To"] = self.to_addr

        msg.attach(MIMEText(text_body, "plain"))
        msg.attach(MIMEText(html_body, "html"))

        try:
            with smtplib.SMTP(self.smtp_host, self.smtp_port) as server:
                server.starttls()
                server.login(self.user, self.password)
                server.sendmail(self.from_addr, [self.to_addr], msg.as_string())
            logger.info(f"Sent email to {self.to_addr}")
            return True
        except smtplib.SMTPException as e:
            logger.error(f"Failed to send email: {e}")
            return False


class GmailNotifier(Notifier):
    """Send notifications via Gmail API with OAuth2."""

    def __init__(
        self,
        client_id: str,
        client_secret: str,
        refresh_token: str,
        address: str,
    ):
        self.client_id = client_id
        self.client_secret = client_secret
        self.refresh_token = refresh_token
        self.address = address

    def _format_html(self, cves: list[CVE]) -> str:
        rows = []
        for cve in cves:
            short_desc = cve.description[:150]
            if len(cve.description) > 150:
                short_desc += "..."
            rows.append(f"""
<tr>
    <td><a href="https://nvd.nist.gov/vuln/detail/{cve.id}">{cve.id}</a></td>
    <td>{cve.score}</td>
    <td>{cve.product}</td>
    <td>{short_desc}</td>
</tr>""")

        return f"""
<html>
<body>
<h2>Critical CVE Alert</h2>
<p>Found {len(cves)} critical CVE(s) matching your watchlist:</p>
<table border="1" cellpadding="5">
<tr><th>CVE</th><th>CVSS</th><th>Product</th><th>Description</th></tr>
{"".join(rows)}
</table>
</body>
</html>"""

    async def _get_access_token(self, session: aiohttp.ClientSession) -> str | None:
        """Get access token using refresh token."""
        try:
            async with session.post(
                "https://oauth2.googleapis.com/token",
                data={
                    "client_id": self.client_id,
                    "client_secret": self.client_secret,
                    "refresh_token": self.refresh_token,
                    "grant_type": "refresh_token",
                },
            ) as resp:
                data = await resp.json()
                if "access_token" in data:
                    return data["access_token"]
                logger.error(f"Failed to get access token: {data}")
                return None
        except aiohttp.ClientError as e:
            logger.error(f"OAuth token request failed: {e}")
            return None

    async def test_credentials(self) -> bool:
        """Test OAuth2 token exchange."""
        async with aiohttp.ClientSession() as session:
            token = await self._get_access_token(session)
            if token:
                logger.info("Gmail OAuth2 credentials valid")
                return True
            return False

    def _create_raw_email(self, subject: str, html_content: str) -> str:
        """Create base64url-encoded email for Gmail API."""
        msg = MIMEMultipart("alternative")
        msg["From"] = f'"CVE Scanner" <{self.address}>'
        msg["To"] = self.address
        msg["Subject"] = subject

        msg.attach(MIMEText("View in HTML-capable email client.", "plain"))
        msg.attach(MIMEText(html_content, "html"))

        raw = msg.as_bytes()
        return urlsafe_b64encode(raw).decode().rstrip("=")

    async def _send_via_api(
        self,
        session: aiohttp.ClientSession,
        subject: str,
        html_content: str,
        *,
        dry_run: bool = False,
    ) -> bool:
        """Send email via Gmail API."""
        access_token = await self._get_access_token(session)
        if not access_token:
            return False

        if dry_run:
            logger.info("[DRY RUN] Gmail OAuth2 credentials valid")
            logger.info(f"[DRY RUN] Would send email to {self.address}")
            logger.info(f"[DRY RUN] Subject: {subject}")
            logger.info("[DRY RUN] --- HTML Body ---")
            print(html_content)
            return True

        raw_email = self._create_raw_email(subject, html_content)

        try:
            async with session.post(
                "https://gmail.googleapis.com/gmail/v1/users/me/messages/send",
                headers={
                    "Authorization": f"Bearer {access_token}",
                    "Content-Type": "application/json",
                },
                json={"raw": raw_email},
            ) as resp:
                data = await resp.json()
                if "id" in data:
                    logger.info(f"Email sent via Gmail API: {data['id']}")
                    return True
                logger.error(f"Gmail API error: {data}")
                return False
        except aiohttp.ClientError as e:
            logger.error(f"Gmail API request failed: {e}")
            return False

    async def send(self, cves: list[CVE], *, dry_run: bool = False) -> bool:
        if not cves:
            logger.debug("No CVEs to notify")
            return True

        subject = f"Critical CVE Alert: {len(cves)} vulnerabilities found"
        html_content = self._format_html(cves)

        async with aiohttp.ClientSession() as session:
            return await self._send_via_api(
                session, subject, html_content, dry_run=dry_run
            )

    async def send_raw(
        self, subject: str, html_content: str, *, dry_run: bool = False
    ) -> bool:
        async with aiohttp.ClientSession() as session:
            return await self._send_via_api(
                session, subject, html_content, dry_run=dry_run
            )
