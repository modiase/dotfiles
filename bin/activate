#!/usr/bin/env bash
set -eu

LOG_LEVEL=2
MAX_CORES=$(($(nproc) - 1))
LOCK_TIMEOUT=30
COLOR_ENABLED=true
PRETTY=${PRETTY:-1}
USE_MAIN_WORKTREE=0
TARGET_HOST=""

[ -n "${CI:-}" ] && [ "$CI" != "0" ] && PRETTY=0

show_usage() {
    local exit_code=${1:-0}
    cat <<EOF
Usage: $0 [-h] [-l LEVEL] [-c CORES] [-t TIMEOUT] [--no-pretty] [--main] [--host HOST]

Activate dotfiles configuration for Darwin or NixOS systems.

Options:
    -h            Show this help message
    -l LEVEL      Set log level (default: 2)
                  1 = minimal output (errors and completion only)
                  2 = show stdout from rebuild processes
                  3+ = enable debug mode (set -x)
    -c CORES      Set max cores for parallel builds (default: $(nproc) - 1)
    -t TIMEOUT    Set lock timeout in minutes (default: 30)
                  Prevents concurrent activations and detects hung processes
    --no-pretty   Disable pretty output (no spinner)
                  Auto-enabled when CI environment variable is set
    --main        Run activate from the latest main
    --host HOST   Run 'activate --main' on remote host(s) via SSH
                  Use 'all' to deploy to all remotely-manageable hosts in parallel
                  Manageable hosts are defined by dotfiles.manageRemotely = true

Examples:
    $0                  # Activate with default settings
    $0 -l 2             # Show rebuild process output
    $0 -l 3             # Enable debug mode
    $0 -c 4             # Use 4 cores for builds
    $0 -t 60            # Use 60-minute timeout
    $0 --no-pretty      # Disable spinner
    $0 --main           # Activate from latest main branch
    $0 --host pallas    # Deploy to pallas via SSH
    $0 --host all       # Deploy to all manageable hosts in parallel
    $0 -h               # Show this help

The script will:
- Update Darwin/NixOS system configuration
- Update home-manager configuration
- Use $(nproc) - 1 cores for parallel builds by default
- Prevent concurrent activations with file locking
- Show progress with spinner (unless disabled with -p)

All output is timestamped and colorized when possible.
EOF
    exit "$exit_code"
}

ARGS=()
SKIP_NEXT=0
for i in $(seq 1 $#); do
    if [ "$SKIP_NEXT" -eq 1 ]; then
        SKIP_NEXT=0
        continue
    fi
    arg="${!i}"
    case "$arg" in
        --main)
            USE_MAIN_WORKTREE=1
            ;;
        --no-pretty)
            PRETTY=0
            ;;
        --host)
            next_i=$((i + 1))
            if [ "$next_i" -le $# ]; then
                TARGET_HOST="${!next_i}"
                SKIP_NEXT=1
            else
                echo "Error: --host requires a hostname argument" >&2
                show_usage 1
            fi
            ;;
        --host=*)
            TARGET_HOST="${arg#--host=}"
            ;;
        --help)
            show_usage 0
            ;;
        *)
            ARGS+=("$arg")
            ;;
    esac
done
set -- "${ARGS[@]+"${ARGS[@]}"}"

while getopts "hl:c:t:" opt; do
    case $opt in
        h)
            show_usage 0
            ;;
        l)
            if [[ "$OPTARG" =~ ^[0-9]+$ ]]; then
                LOG_LEVEL=$OPTARG
            else
                echo "Error: -l requires a positive integer" >&2
                show_usage 1
            fi
            ;;
        c)
            if [[ "$OPTARG" =~ ^[0-9]+$ ]]; then
                MAX_CORES=$OPTARG
            else
                echo "Error: -c requires a positive integer" >&2
                show_usage 1
            fi
            ;;
        t)
            if [[ "$OPTARG" =~ ^[0-9]+$ ]]; then
                LOCK_TIMEOUT=$OPTARG
            else
                echo "Error: -t requires a positive integer (minutes)" >&2
                show_usage 1
            fi
            ;;
        \?)
            show_usage 1
            ;;
    esac
done

shift $((OPTIND - 1))

if [ $# -ne 0 ]; then
    echo "Unknown arguments: $*" >&2
    show_usage 1
fi

if [ -n "$TARGET_HOST" ]; then
    REPO_ROOT="$(git rev-parse --show-toplevel)"

    get_manageable_hosts() {
        nix eval --impure --raw --expr "
            let
                flake = builtins.getFlake \"git+file://$REPO_ROOT\";
                lib = flake.inputs.nixpkgs.lib;
                darwin = lib.mapAttrsToList (name: cfg:
                    if cfg.config.dotfiles.manageRemotely or false then name else null
                ) (flake.darwinConfigurations or {});
                nixos = lib.mapAttrsToList (name: cfg:
                    if cfg.config.dotfiles.manageRemotely or false then name else null
                ) (flake.nixosConfigurations or {});
            in builtins.concatStringsSep \"\\n\" (lib.filter (x: x != null) (darwin ++ nixos))
        " 2>/dev/null || echo ""
    }

    MANAGEABLE_HOSTS=$(get_manageable_hosts)
    [ -z "$MANAGEABLE_HOSTS" ] && echo "Error: Could not determine manageable hosts from flake" >&2 && \
        echo "Ensure dotfiles.manageRemotely = true is set for target hosts" >&2 && exit 1

    validate_host() { echo "$MANAGEABLE_HOSTS" | grep -qx "$1"; }

    DEPLOY_HOSTS="$MANAGEABLE_HOSTS"
    if [ "$TARGET_HOST" != "all" ]; then
        validate_host "$TARGET_HOST" || {
            echo "Error: '$TARGET_HOST' is not a remotely manageable host" >&2
            echo "" >&2
            echo "Available hosts:" >&2
            echo "$MANAGEABLE_HOSTS" | sed 's/^/  /' >&2
            exit 1
        }
        DEPLOY_HOSTS="$TARGET_HOST"
    fi

    echo "═══════════════════════════════════════════════════════════════════════════════"
    echo "REMOTE DEPLOYMENT"
    echo "═══════════════════════════════════════════════════════════════════════════════"
    echo "Deploying to: $(echo $DEPLOY_HOSTS | tr '\n' ' ')"
    echo ""

    RESULT_DIR=$(mktemp -d)
    trap "rm -rf $RESULT_DIR" EXIT

    for host in $DEPLOY_HOSTS; do
        (
            prefix=$(printf "%-16s| " "$host")
            ssh "$host" "cd ~/Dotfiles && ./bin/activate --main" 2>&1 | sed "s/^/$prefix/"
            echo ${PIPESTATUS[0]} > "$RESULT_DIR/$host"
        ) &
    done

    wait

    echo ""
    FAILED=0
    for host in $DEPLOY_HOSTS; do
        result=$(cat "$RESULT_DIR/$host" 2>/dev/null || echo 1)
        [ "$result" -eq 0 ] && echo "✓ $host: success" || { echo "✗ $host: FAILED"; FAILED=1; }
    done

    echo ""
    [ "$FAILED" -eq 0 ] && echo "Remote deployment complete: all hosts succeeded" && exit 0
    echo "Remote deployment complete: some hosts failed"
    exit 1
fi

if [ "$USE_MAIN_WORKTREE" -eq 1 ]; then
    REPO_ROOT="$(git rev-parse --show-toplevel)"
    WORKTREE_PATH="${REPO_ROOT}/worktrees/main"

    echo "Fetching latest from origin..."
    git -C "$REPO_ROOT" fetch origin main

    ORIGIN_MAIN=$(git -C "$REPO_ROOT" rev-parse origin/main)
    make_readonly() { find "$WORKTREE_PATH" -type f -not -path '*/.git/*' -exec chmod a-w {} \; 2>/dev/null || true; }

    if [ -d "$WORKTREE_PATH" ]; then
        CURRENT_HEAD=$(git -C "$WORKTREE_PATH" rev-parse HEAD)
        [ "$CURRENT_HEAD" = "$ORIGIN_MAIN" ] && \
            echo "Already at origin/main (${ORIGIN_MAIN:0:8}), nothing to do" && exit 0
        echo "Updating worktree to origin/main..."
        git -C "$WORKTREE_PATH" reset --hard origin/main
        make_readonly
    else
        echo "Creating main worktree..."
        mkdir -p "${REPO_ROOT}/worktrees"
        git -C "$REPO_ROOT" worktree add --detach "$WORKTREE_PATH" origin/main
        make_readonly
    fi

    echo "Running activate from main worktree..."
    PRETTY_FLAG=""
    [ "${PRETTY:-1}" -eq 0 ] && PRETTY_FLAG="--no-pretty"
    exec "$WORKTREE_PATH/bin/activate" -l "$LOG_LEVEL" -c "$MAX_CORES" -t "$LOCK_TIMEOUT" $PRETTY_FLAG
fi

if [ "$LOG_LEVEL" -ge 3 ]; then
    set -x
fi

set -o pipefail
export NIX_CONFIG="experimental-features = nix-command flakes"

if [ "$(uname -s)" = "Darwin" ]; then
    LOCKFILE="/tmp/dotfiles-activate-${UID}.lock"
else
    LOCKFILE="${XDG_RUNTIME_DIR:-/tmp}/dotfiles-activate-${UID}.lock"
fi
LOCK_ACQUIRED=0

acquire_lock() {
    local lockdir="${LOCKFILE}.d"
    local pidfile="$lockdir/pid"
    local tsfile="$lockdir/timestamp"
    local timeoutfile="$lockdir/timeout"
    local timeout_seconds=$((LOCK_TIMEOUT * 60))
    local wait_elapsed=0
    local max_wait=$timeout_seconds

    while ! mkdir "$lockdir" 2>/dev/null; do
        local lock_pid lock_ts lock_timeout lock_age
        lock_pid=$(cat "$pidfile" 2>/dev/null)
        lock_ts=$(cat "$tsfile" 2>/dev/null)
        lock_timeout=$(cat "$timeoutfile" 2>/dev/null)

        if [ -n "$lock_pid" ] && ! kill -0 "$lock_pid" 2>/dev/null; then
            echo "Removing stale lock (PID $lock_pid no longer exists)"
            rm -rf "$lockdir"
            continue
        fi

        if [ -n "$lock_ts" ] && [ -n "$lock_timeout" ]; then
            lock_age=$(($(date +%s) - lock_ts))
            local lock_timeout_seconds=$((lock_timeout * 60))
            if [ "$lock_age" -ge "$lock_timeout_seconds" ]; then
                echo "Removing stale lock (held for ${lock_age}s, timeout ${lock_timeout_seconds}s)"
                rm -rf "$lockdir"
                continue
            fi
        fi

        if [ "$wait_elapsed" -ge "$max_wait" ]; then
            echo "Error: Could not acquire lock after waiting ${LOCK_TIMEOUT} minutes (held by PID: ${lock_pid:-unknown})" >&2
            return 1
        fi

        if [ "$wait_elapsed" -eq 0 ]; then
            echo "Waiting for lock held by PID ${lock_pid:-unknown}"
        fi

        local remaining=$((max_wait - wait_elapsed))
        echo "Waiting for lock... (${wait_elapsed}s elapsed, ${remaining}s remaining)"
        sleep 5
        wait_elapsed=$((wait_elapsed + 5))
    done

    echo $$ >"$pidfile"
    date +%s >"$tsfile"
    echo "$LOCK_TIMEOUT" >"$timeoutfile"
    LOCK_ACQUIRED=1
    return 0
}

release_lock() {
    if [ "$LOCK_ACQUIRED" -eq 1 ]; then
        rm -rf "${LOCKFILE}.d"
    fi
}

cleanup_and_exit() {
    release_lock
    exit 130
}

trap release_lock EXIT
trap cleanup_and_exit INT TERM

COLOR_ENABLED=${COLOR_ENABLED:-true}
LOGGING_NO_PREFIX=${LOGGING_NO_PREFIX:-0}
REPO_ROOT="$(git rev-parse --show-toplevel)"
source "$REPO_ROOT/lib/lib.sh"

log_to_system "info" "Activation started by $USER (timeout: ${LOCK_TIMEOUT}m, cores: ${MAX_CORES})"

if ! acquire_lock; then
    log_to_system "error" "Failed to acquire lock, aborting activation"
    exit 1
fi

log_to_system "info" "Lock acquired successfully"

if [ "$(uname -s)" = "Darwin" ]; then
    curl --proto '=https' --tlsv1.2 -sSf -L https://github.com/NixOS/nix/raw/master/scripts/sequoia-nixbld-user-migration.sh | bash - >/dev/null 2>&1 || true
fi

if [ -e "/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh" ]; then
    . "/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh"
fi
if [ -e "$HOME/.nix-profile/etc/profile.d/nix.sh" ]; then
    . "$HOME/.nix-profile/etc/profile.d/nix.sh"
fi

for cmd in git nix; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
        log_error "Required command '$cmd' not found."
        log_error "Please ensure git and nix are installed and in your PATH."
        exit 1
    fi
done

OS=$(uname -s)
ARCH=$(uname -m)

case "$OS" in
    "Darwin")
        if ! command -v darwin-rebuild >/dev/null 2>&1; then
            log_to_system "info" "Installing nix-darwin..."
            REBUILD_CMD="nix run nix-darwin/master#darwin-rebuild --"
        else
            log_to_system "info" "Updating nix-darwin configuration..."
            REBUILD_CMD="darwin-rebuild"
        fi
        if ! run_logged "darwin-rebuild" "$COLOR_WHITE" sudo NIX_CONFIG="$NIX_CONFIG" "$REBUILD_CMD" switch --flake "$REPO_ROOT" --max-jobs "$MAX_CORES" --cores "$MAX_CORES"; then
            exit 1
        fi
        HOME_MANAGER_TARGET="moye-aarch64-darwin"
        ;;
    "Linux")
        if [ -f /etc/NIXOS ]; then
            log_to_system "info" "Updating NixOS configuration..."
            if ! run_logged "nixos-rebuild" "$COLOR_WHITE" sudo nixos-rebuild switch --flake "$REPO_ROOT" --max-jobs "$MAX_CORES" --cores "$MAX_CORES"; then
                exit 1
            fi
        fi

        case "$ARCH" in
            "aarch64" | "arm64") HOME_MANAGER_TARGET="moye-aarch64-linux" ;;
            "x86_64") HOME_MANAGER_TARGET="moye-x86_64-linux" ;;
            *)
                log_error "Unsupported Linux architecture '$ARCH'"
                exit 1
                ;;
        esac
        ;;
    *)
        log_error "Unsupported operating system '$OS'"
        exit 1
        ;;
esac

if ! run_logged "home-manager" "$COLOR_WHITE" nix shell nixpkgs#home-manager -c home-manager switch -b backup --flake "$REPO_ROOT#$HOME_MANAGER_TARGET"; then
    exit 1
fi

log_to_system "info" "Configuration updated successfully"
