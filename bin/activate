#!/usr/bin/env bash
# shellcheck shell=bash
set -euo pipefail

LOCK_TIMEOUT=30
LOG_LEVEL="${DOTFILES_ACTIVATE_LOG_LEVEL-2}"
MAX_CORES=$(($(getconf _NPROCESSORS_ONLN) - 1))
SYSTEM_OVERRIDE="${hostname_override:-}"

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

if [[ "$SCRIPT_DIR" != "$HOME/dotfiles/bin" && "$SCRIPT_DIR" != "$HOME/dotfiles/worktrees/main/bin" ]]; then
    echo "ERROR: activate must be run from \$HOME/dotfiles, not $SCRIPT_DIR" >&2
    exit 1
fi

REPO_ROOT="$(cd "$SCRIPT_DIR/.." && git rev-parse --show-toplevel)"

export NIX_CONFIG="experimental-features = nix-command flakes"

EXIT_HOOKS=()
add_exit_hook() { EXIT_HOOKS+=("$1"); }
run_exit_hooks() {
    EXIT_CODE=$?
    local i
    for ((i = ${#EXIT_HOOKS[@]} - 1; i >= 0; i--)); do
        eval "${EXIT_HOOKS[i]}" || true
    done
}
trap run_exit_hooks EXIT
_DATE=date _MKDIR=mkdir _MKTEMP=mktemp _CAT=cat _TAIL=tail
_FLOCK=$(command -v flock) || _FLOCK="nix shell nixpkgs#flock -c flock"
_SHA256SUM=$(command -v sha256sum) || _SHA256SUM="nix shell nixpkgs#coreutils -c sha256sum"
_CURL=$(command -v curl) || _CURL="nix shell nixpkgs#curl -c curl"
_DING=$(command -v ding) || _DING=":"
# shellcheck source=/dev/null
source "$REPO_ROOT/nix/nixpkgs/shellutils/logging-utils.sh"

GIT_COMMON_DIR="$(cd "$REPO_ROOT" && git rev-parse --git-common-dir)"
[[ "$GIT_COMMON_DIR" != /* ]] && GIT_COMMON_DIR="$REPO_ROOT/$GIT_COMMON_DIR"
GITCRYPT_KEY="$GIT_COMMON_DIR/git-crypt/keys/default"
GITCRYPT_FINGERPRINT="98aa7b921fe81d9a38ae89f69c73fc72ea60c0ebb58170796507d476cbee33f5"

show_usage() {
    local exit_code=${1:-0}
    cat <<EOF
Usage: $0 [-h] [-l LEVEL] [-c CORES] [-t TIMEOUT] [-s SYSTEM]
       $0 deploy [HOST|all]
       $0 show [HOST]

Activate dotfiles configuration for Darwin or NixOS systems.

Subcommands:
    deploy [HOST]  Deploy from origin/main
                   HOST defaults to localhost
                   Use 'all' for all manageable hosts in parallel
    show [HOST]    Show activation status

Options:
    -c CORES       Set max cores for parallel builds (default: $(getconf _NPROCESSORS_ONLN) - 1)
    -h             Show this help message
    -l LEVEL       Set log level (default: 2)
                   1 = minimal (errors only)
                   2 = normal (spinners + completion)
                   3 = verbose (full command output)
                   4+ = debug (set -x trace)
    -s, --system SYSTEM
                   Override system name for config selection (useful for new machines)
    -t TIMEOUT     Lock timeout in minutes (default: 30)

Environment:
    DOTFILES_SYSTEM   Same as -s/--system (flag takes precedence)

Examples:
    $0                       # Activate current repo state
    $0 -s hephaistos         # Activate hephaistos config on this machine
    $0 --system hephaistos   # Same as above
    $0 deploy                # Deploy origin/main to localhost
    $0 deploy herakles       # Deploy to herakles via SSH
    $0 deploy all            # Deploy to all manageable hosts
    $0 show                  # Show activation status
EOF
    exit "$exit_code"
}

if [ "$(uname -s)" = "Darwin" ]; then
    STATE_DIR="$HOME/.local/state/dotfiles"
else
    STATE_DIR="${XDG_STATE_HOME:-$HOME/.local/state}/dotfiles"
fi
SYSTEM_STATE="$STATE_DIR/system-activated"
HOME_STATE="$STATE_DIR/home-activated"

is_activated() {
    local state_file="$1" target_hash="$2"
    [ -f "$state_file" ] && [ "$(cat "$state_file")" = "$target_hash" ]
}

record_state() {
    local state_file="$1" hash="$2"
    mkdir -p "$STATE_DIR"
    local temp
    temp=$(mktemp "$STATE_DIR/.state.XXXXXX")
    echo "$hash" >"$temp"
    mv "$temp" "$state_file"
}

if [ "$(uname -s)" = "Darwin" ]; then
    LOCKFILE="/tmp/dotfiles-activate-${UID}.lock"
else
    LOCKFILE="${XDG_RUNTIME_DIR:-/tmp}/dotfiles-activate-${UID}.lock"
fi

is_in_worktree() {
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    [[ "$script_dir" == */worktrees/main/* ]]
}

ensure_in_worktree() {
    is_in_worktree && return 0

    local worktree_path="$HOME/dotfiles/worktrees/main"

    git -C "$HOME/dotfiles" fetch origin main 2>/dev/null || true

    local origin_main
    origin_main=$(git -C "$HOME/dotfiles" rev-parse origin/main 2>/dev/null) || return 0

    local main_git_dir
    main_git_dir="$(git -C "$HOME/dotfiles" rev-parse --git-common-dir)"
    local worktree_gitdir="$main_git_dir/worktrees/main"

    if [ -d "$worktree_path" ]; then
        if [ ! -f "$worktree_gitdir/git-crypt/keys/default" ]; then
            mkdir -p "$worktree_gitdir/git-crypt/keys"
            ln "$main_git_dir/git-crypt/keys/default" "$worktree_gitdir/git-crypt/keys/default" 2>/dev/null || true
        fi
        if ! git -C "$worktree_path" crypt status &>/dev/null; then
            log_debug "git-crypt broken in worktree, recreating"
            rm -rf "$worktree_path"
            git -C "$HOME/dotfiles" worktree prune 2>/dev/null || true
        else
            local current_head
            current_head=$(git -C "$worktree_path" rev-parse HEAD 2>/dev/null) || true
            [ "$current_head" != "$origin_main" ] &&
                git -C "$worktree_path" reset --hard origin/main 2>&1 | log_debug_to_pipe "git-reset" || true
        fi
    fi

    if [ ! -d "$worktree_path" ]; then
        mkdir -p "$HOME/dotfiles/worktrees"
        git -C "$HOME/dotfiles" worktree add --no-checkout --detach "$worktree_path" origin/main 2>&1 | log_debug_to_pipe "git-worktree" || return 0
        mkdir -p "$worktree_gitdir/git-crypt/keys"
        ln "$main_git_dir/git-crypt/keys/default" "$worktree_gitdir/git-crypt/keys/default" 2>/dev/null || true
        git -C "$worktree_path" checkout --force HEAD 2>&1 | log_debug_to_pipe "git-checkout" || true
    fi

    exec "$worktree_path/bin/activate" "$@"
}

do_show() {
    local host="${1:-}"
    local repo_root="$HOME/dotfiles"

    [ -n "$host" ] && {
        ssh "$host" "cd ~/dotfiles && ./bin/activate show"
        return
    }

    git -C "$repo_root" fetch origin main 2>/dev/null || true

    local worktree="$repo_root/worktrees/main"
    local c_cyan=$'\033[38;5;116m' c_green=$'\033[38;5;108m' c_blue=$'\033[38;5;110m'
    local c_purple=$'\033[38;5;139m' c_magenta=$'\033[38;5;175m' c_yellow=$'\033[38;5;222m' c_reset=$'\033[0m'

    local origin_main worktree_head system_hash home_hash val_color
    origin_main=$(git -C "$repo_root" rev-parse origin/main 2>/dev/null || echo "(unknown)")
    [ -d "$worktree" ] && worktree_head=$(git -C "$worktree" rev-parse HEAD 2>/dev/null || echo "(not created)") || worktree_head="(not created)"
    system_hash=$(cat "$SYSTEM_STATE" 2>/dev/null || echo "(not set)")
    home_hash=$(cat "$HOME_STATE" 2>/dev/null || echo "(not set)")

    printf "${c_cyan}%-20s${c_reset} ${c_green}%s${c_reset}\n" "origin/main:" "$origin_main"

    [ "$worktree_head" = "$origin_main" ] && val_color=$c_green || val_color=$c_yellow
    printf "${c_blue}%-20s${c_reset} ${val_color}%s${c_reset}\n" "worktree HEAD:" "$worktree_head"

    [ "$system_hash" = "$origin_main" ] && val_color=$c_green || val_color=$c_yellow
    printf "${c_purple}%-20s${c_reset} ${val_color}%s${c_reset}\n" "system activated:" "$system_hash"

    [ "$home_hash" = "$origin_main" ] && val_color=$c_green || val_color=$c_yellow
    printf "${c_magenta}%-20s${c_reset} ${val_color}%s${c_reset}\n" "home activated:" "$home_hash"
}

# shellcheck disable=SC2016  # Variables expand on remote, not locally
DEPLOY_CMD='cd ~/dotfiles && git fetch origin main && (git diff --quiet && git diff --cached --quiet && git reset --hard origin/main) || true; main_gitdir="$(git rev-parse --git-common-dir)"; wt_gitdir="$main_gitdir/worktrees/main"; if [ -d worktrees/main ]; then [ ! -f "$wt_gitdir/git-crypt/keys/default" ] && mkdir -p "$wt_gitdir/git-crypt/keys" && ln "$main_gitdir/git-crypt/keys/default" "$wt_gitdir/git-crypt/keys/default" 2>/dev/null; git -C worktrees/main reset --hard origin/main; else git worktree add --no-checkout --detach worktrees/main origin/main && mkdir -p "$wt_gitdir/git-crypt/keys" && ln "$main_gitdir/git-crypt/keys/default" "$wt_gitdir/git-crypt/keys/default" && git -C worktrees/main checkout --force HEAD; fi && ./worktrees/main/bin/activate'

deploy_local() {
    local origin_main
    origin_main=$(git -C "$REPO_ROOT" rev-parse HEAD)

    is_activated "$SYSTEM_STATE" "$origin_main" && is_activated "$HOME_STATE" "$origin_main" && {
        echo "Already activated ${origin_main:0:8}, nothing to do"
        return 0
    }

    do_activate
}

deploy_remote() {
    local host="$1"
    # shellcheck disable=SC2029  # intentional: DEPLOY_CMD runs on remote
    ssh "$host" "$DEPLOY_CMD"
}

get_manage_options() {
    local host="$1" result
    result=$(nix eval --impure --json --expr "
        let
            flake = builtins.getFlake \"git+file://$REPO_ROOT\";
            cfg = flake.darwinConfigurations.$host.config.dotfiles
                or flake.nixosConfigurations.$host.config.dotfiles
                or null;
        in if cfg == null then null else { inherit (cfg) manageSystem manageHome; }
    " 2>/dev/null) || {
        log_error "Failed to query manage options for $host: $result"
        exit 1
    }
    [[ "$result" == "null" ]] && {
        log_error "No configuration found for host: $host"
        exit 1
    }
    echo "$result"
}

deploy_all() {
    get_manageable_hosts() {
        nix eval --impure --raw --expr "
            let
                flake = builtins.getFlake \"git+file://$REPO_ROOT\";
                lib = flake.inputs.nixpkgs.lib;
                darwin = lib.mapAttrsToList (name: cfg:
                    if cfg.config.dotfiles.manageRemotely or false then name else null
                ) (flake.darwinConfigurations or {});
                nixos = lib.mapAttrsToList (name: cfg:
                    if cfg.config.dotfiles.manageRemotely or false then name else null
                ) (flake.nixosConfigurations or {});
            in builtins.concatStringsSep \"\\n\" (lib.filter (x: x != null) (darwin ++ nixos))
        " 2>/dev/null || echo ""
    }

    local hosts current_host
    current_host=$(hostname -s)
    hosts=$(get_manageable_hosts | sed "s/^${current_host}$/localhost/")
    [ -z "$hosts" ] && {
        echo "Error: No manageable hosts found (dotfiles.manageRemotely = true)" >&2
        exit 1
    }

    echo "═══════════════════════════════════════════════════════════════════════════════"
    echo "REMOTE DEPLOYMENT"
    echo "═══════════════════════════════════════════════════════════════════════════════"
    echo "Deploying to: $(echo "$hosts" | tr '\n' ' ')"
    echo ""

    local result_dir
    result_dir=$(mktemp -d)
    add_exit_hook "rm -rf $result_dir"

    for host in $hosts; do
        (
            local prefix
            prefix=$(printf "%-16s| " "$host")
            if [ "$host" = "localhost" ]; then
                bash -c "$DEPLOY_CMD" 2>&1 | sed "s/^/$prefix/"
            else
                # shellcheck disable=SC2029  # intentional: DEPLOY_CMD runs on remote
                ssh "$host" "$DEPLOY_CMD" 2>&1 | sed "s/^/$prefix/"
            fi
            echo "${PIPESTATUS[0]}" >"$result_dir/$host"
        ) &
    done

    wait

    echo ""
    local failed=0
    for host in $hosts; do
        local result
        result=$(cat "$result_dir/$host" 2>/dev/null || echo 1)
        if [ "$result" -eq 0 ]; then
            echo "✓ $host: success"
        else
            echo "✗ $host: FAILED"
            failed=1
        fi
    done

    echo ""
    [ "$failed" -eq 0 ] && echo "Remote deployment complete: all hosts succeeded" && return 0
    echo "Remote deployment complete: some hosts failed"
    return 1
}

do_deploy() {
    local host="${1:-localhost}"

    case "$host" in
        all) deploy_all ;;
        localhost) deploy_local ;;
        *) deploy_remote "$host" ;;
    esac
}

_ding_on_exit() {
    # shellcheck disable=SC2153  # EXIT_CODE set by run_exit_hooks in hook-utils.sh
    if [[ $EXIT_CODE -eq 0 ]]; then
        $_DING -i "Activate" -m "Completed successfully"
    else
        $_DING -i "Activate" -m "Failed"
    fi
}

do_activate() {
    add_exit_hook _ding_on_exit
    if [ "$LOG_LEVEL" -ge 4 ]; then enable_log_tracing; fi

    if [ -f "$GITCRYPT_KEY" ]; then
        actual_fp=$($_SHA256SUM "$GITCRYPT_KEY" | cut -d' ' -f1)
        if [ "$actual_fp" = "$GITCRYPT_FINGERPRINT" ]; then
            log_debug "git-crypt key verified"
        else
            log_error "git-crypt key fingerprint mismatch (expected: ${GITCRYPT_FINGERPRINT:0:16}..., got: ${actual_fp:0:16}...)"
            exit 1
        fi
    else
        log_error "git-crypt key not found - run 'git-crypt unlock' first"
        exit 1
    fi

    trap 'exit 130' INT TERM

    log_to_system "info" "Activation started by $USER (timeout: ${LOCK_TIMEOUT}m, cores: ${MAX_CORES})"

    exec 9>"$LOCKFILE"
    $_FLOCK -w $((LOCK_TIMEOUT * 60)) 9 || {
        log_to_system "error" "Failed to acquire lock after ${LOCK_TIMEOUT} minutes"
        exit 1
    }
    log_to_system "info" "Lock acquired successfully"

    [ "$(uname -s)" = "Darwin" ] &&
        $_CURL --proto '=https' --tlsv1.2 -sSf -L https://github.com/NixOS/nix/raw/master/scripts/sequoia-nixbld-user-migration.sh | bash - 2>&1 | log_debug_to_pipe "nix-migration" || true

    # shellcheck source=/dev/null
    [ -e "/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh" ] &&
        . "/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh" || true
    # shellcheck source=/dev/null
    [ -e "$HOME/.nix-profile/etc/profile.d/nix.sh" ] &&
        . "$HOME/.nix-profile/etc/profile.d/nix.sh" || true

    for cmd in git nix jq; do
        command -v "$cmd" >/dev/null 2>&1 || {
            log_error "Required command '$cmd' not found."
            exit 1
        }
    done

    local os target_hash
    os=$(uname -s)
    target_hash=$(git -C "$REPO_ROOT" rev-parse HEAD)

    local config_hostname flake_target
    config_hostname="${SYSTEM_OVERRIDE:-$(hostname -s)}"
    HOME_MANAGER_TARGET="$USER-$config_hostname"
    flake_target="git+file://$REPO_ROOT#$config_hostname"

    [ -n "$SYSTEM_OVERRIDE" ] && log_debug "Using system: $SYSTEM_OVERRIDE"

    local manage_opts manage_system manage_home
    manage_opts=$(get_manage_options "$config_hostname")
    manage_system=$(echo "$manage_opts" | jq -r '.manageSystem')
    manage_home=$(echo "$manage_opts" | jq -r '.manageHome')

    log_debug "manageSystem=$manage_system, manageHome=$manage_home"

    case "$os" in
        Darwin)
            if [ "$manage_system" = "true" ]; then
                local rebuild_cmd="darwin-rebuild"
                command -v darwin-rebuild >/dev/null 2>&1 || {
                    log_to_system "info" "Installing nix-darwin..."
                    rebuild_cmd="nix run nix-darwin/master#darwin-rebuild --"
                }
                # shellcheck disable=SC2086 # rebuild_cmd intentionally word-split for multi-word command
                run_logged "darwin-rebuild" sudo NIX_CONFIG="$NIX_CONFIG" $rebuild_cmd switch \
                    --flake "$flake_target" --max-jobs "$MAX_CORES" --cores "$MAX_CORES" &&
                    record_state "$SYSTEM_STATE" "$target_hash" || exit 1
            else
                log_info "Skipping system management (manageSystem=false)"
                record_state "$SYSTEM_STATE" "$target_hash"
            fi
            ;;
        Linux)
            if [ "$manage_system" = "true" ]; then
                log_to_system "info" "Updating NixOS configuration..."
                run_logged "nixos-rebuild" sudo nixos-rebuild switch \
                    --flake "$flake_target" --max-jobs "$MAX_CORES" --cores "$MAX_CORES" &&
                    record_state "$SYSTEM_STATE" "$target_hash" || exit 1
            else
                log_info "Skipping system management (manageSystem=false)"
                record_state "$SYSTEM_STATE" "$target_hash"
            fi
            ;;
        *)
            log_error "Unsupported OS '$os'"
            exit 1
            ;;
    esac

    if [ "$manage_home" = "true" ]; then
        run_logged "home-manager" nix shell nixpkgs#home-manager -c home-manager switch \
            -b backup --flake "git+file://$REPO_ROOT#$HOME_MANAGER_TARGET" &&
            record_state "$HOME_STATE" "$target_hash" || exit 1
    else
        log_info "Skipping home management (manageHome=false)"
        record_state "$HOME_STATE" "$target_hash"
    fi

    log_to_system "info" "Configuration updated successfully"
}

parse_global_opts() {
    while [ $# -gt 0 ]; do
        case "$1" in
            -c)
                MAX_CORES="$2"
                shift 2
                ;;
            -h | --help) show_usage 0 ;;
            -l)
                LOG_LEVEL="$2"
                shift 2
                ;;
            -s | --system)
                SYSTEM_OVERRIDE="$2"
                shift 2
                ;;
            -t)
                LOCK_TIMEOUT="$2"
                shift 2
                ;;
            -*)
                echo "Unknown option: $1" >&2
                show_usage 1
                ;;
            *) break ;;
        esac
    done
    REMAINING_ARGS=("$@")
}

main() {
    parse_global_opts "$@"
    set -- ${REMAINING_ARGS[@]+"${REMAINING_ARGS[@]}"}

    case "${1:-}" in
        deploy)
            ensure_in_worktree -l "$LOG_LEVEL" -c "$MAX_CORES" -t "$LOCK_TIMEOUT" "$@"
            shift
            do_deploy "$@"
            ;;
        show)
            ensure_in_worktree -l "$LOG_LEVEL" -c "$MAX_CORES" -t "$LOCK_TIMEOUT" "$@"
            shift
            do_show "$@"
            ;;
        "")
            do_activate
            ;;
        *)
            echo "Unknown subcommand: $1" >&2
            show_usage 1
            ;;
    esac
}

main "$@"
