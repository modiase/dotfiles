#!/usr/bin/env bash
set -eu

LOG_LEVEL=2
MAX_CORES=$(($(nproc) - 1))
LOCK_TIMEOUT=30
COLOR_ENABLED=true
PRETTY=${PRETTY:-1}
USE_MAIN_WORKTREE=0
TARGET_HOST=""
SUBCOMMAND=""
SHOW_TARGET=""

[ -n "${CI:-}" ] && [ "$CI" != "0" ] && PRETTY=0

show_usage() {
    local exit_code=${1:-0}
    cat <<EOF
Usage: $0 [-h] [-l LEVEL] [-c CORES] [-t TIMEOUT] [--no-pretty] [--main] [--host HOST]
       $0 show [HOST]

Activate dotfiles configuration for Darwin or NixOS systems.

Subcommands:
    show [HOST]   Show activation status (origin/main, worktree, system, home hashes)
                  If HOST specified, shows status on that remote machine

Options:
    -h            Show this help message
    -l LEVEL      Set log level (default: 2)
                  1 = minimal output (errors and completion only)
                  2 = show stdout from rebuild processes
                  3+ = enable debug mode (set -x)
    -c CORES      Set max cores for parallel builds (default: $(nproc) - 1)
    -t TIMEOUT    Set lock timeout in minutes (default: 30)
                  Prevents concurrent activations and detects hung processes
    --no-pretty   Disable pretty output (no spinner)
                  Auto-enabled when CI environment variable is set
    --main        Run activate from the latest main
    --host HOST   Run 'activate --main' on remote host(s) via SSH
                  Use 'all' to deploy to all remotely-manageable hosts in parallel
                  Manageable hosts are defined by dotfiles.manageRemotely = true

Examples:
    $0                  # Activate with default settings
    $0 show             # Show activation status on this machine
    $0 show herakles    # Show activation status on herakles
    $0 --main           # Activate from latest main branch
    $0 --host pallas    # Deploy to pallas via SSH
    $0 --host all       # Deploy to all manageable hosts in parallel
    $0 -h               # Show this help

The script will:
- Update Darwin/NixOS system configuration
- Update home-manager configuration
- Use $(nproc) - 1 cores for parallel builds by default
- Prevent concurrent activations with file locking
- Show progress with spinner (unless disabled with -p)

All output is timestamped and colorized when possible.
EOF
    exit "$exit_code"
}

ARGS=()
SKIP_NEXT=0
for i in $(seq 1 $#); do
    if [ "$SKIP_NEXT" -eq 1 ]; then
        SKIP_NEXT=0
        continue
    fi
    arg="${!i}"
    case "$arg" in
        --main)
            USE_MAIN_WORKTREE=1
            ;;
        --no-pretty)
            PRETTY=0
            ;;
        --host)
            next_i=$((i + 1))
            if [ "$next_i" -le $# ]; then
                TARGET_HOST="${!next_i}"
                SKIP_NEXT=1
            else
                echo "Error: --host requires a hostname argument" >&2
                show_usage 1
            fi
            ;;
        --host=*)
            TARGET_HOST="${arg#--host=}"
            ;;
        --help)
            show_usage 0
            ;;
        show)
            SUBCOMMAND="show"
            ;;
        *)
            ARGS+=("$arg")
            ;;
    esac
done
set -- "${ARGS[@]+"${ARGS[@]}"}"

# Handle show subcommand target
[ "$SUBCOMMAND" = "show" ] && [ ${#ARGS[@]} -gt 0 ] && SHOW_TARGET="${ARGS[0]}" && ARGS=("${ARGS[@]:1}")

while getopts "hl:c:t:" opt; do
    case $opt in
        h)
            show_usage 0
            ;;
        l)
            if [[ "$OPTARG" =~ ^[0-9]+$ ]]; then
                LOG_LEVEL=$OPTARG
            else
                echo "Error: -l requires a positive integer" >&2
                show_usage 1
            fi
            ;;
        c)
            if [[ "$OPTARG" =~ ^[0-9]+$ ]]; then
                MAX_CORES=$OPTARG
            else
                echo "Error: -c requires a positive integer" >&2
                show_usage 1
            fi
            ;;
        t)
            if [[ "$OPTARG" =~ ^[0-9]+$ ]]; then
                LOCK_TIMEOUT=$OPTARG
            else
                echo "Error: -t requires a positive integer (minutes)" >&2
                show_usage 1
            fi
            ;;
        \?)
            show_usage 1
            ;;
    esac
done

shift $((OPTIND - 1))

if [ $# -ne 0 ] && [ "$SUBCOMMAND" != "show" ]; then
    echo "Unknown arguments: $*" >&2
    show_usage 1
fi

if [ -n "$TARGET_HOST" ]; then
    REPO_ROOT="$(git rev-parse --show-toplevel)"

    get_manageable_hosts() {
        nix eval --impure --raw --expr "
            let
                flake = builtins.getFlake \"git+file://$REPO_ROOT\";
                lib = flake.inputs.nixpkgs.lib;
                darwin = lib.mapAttrsToList (name: cfg:
                    if cfg.config.dotfiles.manageRemotely or false then name else null
                ) (flake.darwinConfigurations or {});
                nixos = lib.mapAttrsToList (name: cfg:
                    if cfg.config.dotfiles.manageRemotely or false then name else null
                ) (flake.nixosConfigurations or {});
            in builtins.concatStringsSep \"\\n\" (lib.filter (x: x != null) (darwin ++ nixos))
        " 2>/dev/null || echo ""
    }

    MANAGEABLE_HOSTS=$(get_manageable_hosts)
    [ -z "$MANAGEABLE_HOSTS" ] && echo "Error: Could not determine manageable hosts from flake" >&2 && \
        echo "Ensure dotfiles.manageRemotely = true is set for target hosts" >&2 && exit 1

    validate_host() { echo "$MANAGEABLE_HOSTS" | grep -qx "$1"; }

    DEPLOY_HOSTS="$MANAGEABLE_HOSTS"
    if [ "$TARGET_HOST" != "all" ]; then
        validate_host "$TARGET_HOST" || {
            echo "Error: '$TARGET_HOST' is not a remotely manageable host" >&2
            echo "" >&2
            echo "Available hosts:" >&2
            echo "$MANAGEABLE_HOSTS" | sed 's/^/  /' >&2
            exit 1
        }
        DEPLOY_HOSTS="$TARGET_HOST"
    fi

    echo "═══════════════════════════════════════════════════════════════════════════════"
    echo "REMOTE DEPLOYMENT"
    echo "═══════════════════════════════════════════════════════════════════════════════"
    echo "Deploying to: $(echo $DEPLOY_HOSTS | tr '\n' ' ')"
    echo ""

    RESULT_DIR=$(mktemp -d)
    trap "rm -rf $RESULT_DIR" EXIT

    for host in $DEPLOY_HOSTS; do
        (
            prefix=$(printf "%-16s| " "$host")
            ssh "$host" "cd ~/Dotfiles && ./bin/activate --main" 2>&1 | sed "s/^/$prefix/"
            echo ${PIPESTATUS[0]} > "$RESULT_DIR/$host"
        ) &
    done

    wait

    echo ""
    FAILED=0
    for host in $DEPLOY_HOSTS; do
        result=$(cat "$RESULT_DIR/$host" 2>/dev/null || echo 1)
        [ "$result" -eq 0 ] && echo "✓ $host: success" || { echo "✗ $host: FAILED"; FAILED=1; }
    done

    echo ""
    [ "$FAILED" -eq 0 ] && echo "Remote deployment complete: all hosts succeeded" && exit 0
    echo "Remote deployment complete: some hosts failed"
    exit 1
fi

if [ "$(uname -s)" = "Darwin" ]; then
    STATE_DIR="$HOME/.local/state/dotfiles"
else
    STATE_DIR="${XDG_STATE_HOME:-$HOME/.local/state}/dotfiles"
fi
SYSTEM_STATE="$STATE_DIR/system-activated"
HOME_STATE="$STATE_DIR/home-activated"

is_activated() {
    local state_file="$1"
    local target_hash="$2"
    [ -f "$state_file" ] && [ "$(cat "$state_file")" = "$target_hash" ]
}

show_status() {
    local repo_root="$1"
    local worktree="$repo_root/worktrees/main"
    local origin_main worktree_head system_hash home_hash

    # Nord pastel colors (labels)
    local c_cyan=$'\033[38;5;116m'    # Nord 8 - origin/main label
    local c_blue=$'\033[38;5;110m'    # Nord 9 - worktree label
    local c_purple=$'\033[38;5;139m'  # Nord 15 - system label
    local c_magenta=$'\033[38;5;175m' # Nord-ish - home label
    # Value colors
    local c_green=$'\033[38;5;108m'   # Nord 14 - matching
    local c_yellow=$'\033[38;5;222m'  # Nord 13 - not matching
    local c_reset=$'\033[0m'

    origin_main=$(git -C "$repo_root" rev-parse origin/main 2>/dev/null || echo "(unknown)")
    [ -d "$worktree" ] && worktree_head=$(git -C "$worktree" rev-parse HEAD 2>/dev/null || echo "(not created)") || worktree_head="(not created)"
    system_hash=$(cat "$SYSTEM_STATE" 2>/dev/null || echo "(not set)")
    home_hash=$(cat "$HOME_STATE" 2>/dev/null || echo "(not set)")

    local val_color
    printf "${c_cyan}%-20s${c_reset} ${c_green}%s${c_reset}\n" "origin/main:" "$origin_main"

    [ "$worktree_head" = "$origin_main" ] && val_color=$c_green || val_color=$c_yellow
    printf "${c_blue}%-20s${c_reset} ${val_color}%s${c_reset}\n" "worktree HEAD:" "$worktree_head"

    [ "$system_hash" = "$origin_main" ] && val_color=$c_green || val_color=$c_yellow
    printf "${c_purple}%-20s${c_reset} ${val_color}%s${c_reset}\n" "system activated:" "$system_hash"

    [ "$home_hash" = "$origin_main" ] && val_color=$c_green || val_color=$c_yellow
    printf "${c_magenta}%-20s${c_reset} ${val_color}%s${c_reset}\n" "home activated:" "$home_hash"
}

if [ "$SUBCOMMAND" = "show" ]; then
    if [ -n "$SHOW_TARGET" ]; then
        ssh "$SHOW_TARGET" "cd ~/Dotfiles/worktrees/main && ./bin/activate show"
    else
        # Always use ~/Dotfiles as repo root (not git rev-parse, which would return worktree path)
        REPO_ROOT="$HOME/Dotfiles"
        git -C "$REPO_ROOT" fetch origin main 2>/dev/null || true
        show_status "$REPO_ROOT"
    fi
    exit 0
fi

if [ "$USE_MAIN_WORKTREE" -eq 1 ]; then
    REPO_ROOT="$(git rev-parse --show-toplevel)"
    WORKTREE_PATH="${REPO_ROOT}/worktrees/main"

    echo "Fetching latest from origin..."
    git -C "$REPO_ROOT" fetch origin main

    ORIGIN_MAIN=$(git -C "$REPO_ROOT" rev-parse origin/main)
    make_readonly() { find "$WORKTREE_PATH" -type f -not -path '*/.git/*' -exec chmod a-w {} \; 2>/dev/null || true; }

    if [ -d "$WORKTREE_PATH" ]; then
        CURRENT_HEAD=$(git -C "$WORKTREE_PATH" rev-parse HEAD)
        if [ "$CURRENT_HEAD" != "$ORIGIN_MAIN" ]; then
            echo "Updating worktree to origin/main..."
            git -C "$WORKTREE_PATH" reset --hard origin/main
            make_readonly
        fi
    else
        echo "Creating main worktree..."
        mkdir -p "${REPO_ROOT}/worktrees"
        git -C "$REPO_ROOT" worktree add --detach "$WORKTREE_PATH" origin/main
        make_readonly
    fi

    is_activated "$SYSTEM_STATE" "$ORIGIN_MAIN" && \
        is_activated "$HOME_STATE" "$ORIGIN_MAIN" && \
        echo "Already activated ${ORIGIN_MAIN:0:8}, nothing to do" && exit 0

    echo "Running activate from main worktree..."
    PRETTY_FLAG=""
    [ "${PRETTY:-1}" -eq 0 ] && PRETTY_FLAG="--no-pretty"
    exec "$WORKTREE_PATH/bin/activate" -l "$LOG_LEVEL" -c "$MAX_CORES" -t "$LOCK_TIMEOUT" $PRETTY_FLAG
fi

if [ "$LOG_LEVEL" -ge 3 ]; then
    set -x
fi

set -o pipefail
export NIX_CONFIG="experimental-features = nix-command flakes"

if [ "$(uname -s)" = "Darwin" ]; then
    LOCKFILE="/tmp/dotfiles-activate-${UID}.lock"
else
    LOCKFILE="${XDG_RUNTIME_DIR:-/tmp}/dotfiles-activate-${UID}.lock"
fi
LOCK_ACQUIRED=0

acquire_lock() {
    local lockdir="${LOCKFILE}.d"
    local pidfile="$lockdir/pid"
    local tsfile="$lockdir/timestamp"
    local timeoutfile="$lockdir/timeout"
    local timeout_seconds=$((LOCK_TIMEOUT * 60))
    local wait_elapsed=0
    local max_wait=$timeout_seconds

    while ! mkdir "$lockdir" 2>/dev/null; do
        local lock_pid lock_ts lock_timeout lock_age
        lock_pid=$(cat "$pidfile" 2>/dev/null)
        lock_ts=$(cat "$tsfile" 2>/dev/null)
        lock_timeout=$(cat "$timeoutfile" 2>/dev/null)

        if [ -n "$lock_pid" ] && ! kill -0 "$lock_pid" 2>/dev/null; then
            echo "Removing stale lock (PID $lock_pid no longer exists)"
            rm -rf "$lockdir"
            continue
        fi

        if [ -n "$lock_ts" ] && [ -n "$lock_timeout" ]; then
            lock_age=$(($(date +%s) - lock_ts))
            local lock_timeout_seconds=$((lock_timeout * 60))
            if [ "$lock_age" -ge "$lock_timeout_seconds" ]; then
                echo "Removing stale lock (held for ${lock_age}s, timeout ${lock_timeout_seconds}s)"
                rm -rf "$lockdir"
                continue
            fi
        fi

        if [ "$wait_elapsed" -ge "$max_wait" ]; then
            echo "Error: Could not acquire lock after waiting ${LOCK_TIMEOUT} minutes (held by PID: ${lock_pid:-unknown})" >&2
            return 1
        fi

        if [ "$wait_elapsed" -eq 0 ]; then
            echo "Waiting for lock held by PID ${lock_pid:-unknown}"
        fi

        local remaining=$((max_wait - wait_elapsed))
        echo "Waiting for lock... (${wait_elapsed}s elapsed, ${remaining}s remaining)"
        sleep 5
        wait_elapsed=$((wait_elapsed + 5))
    done

    echo $$ >"$pidfile"
    date +%s >"$tsfile"
    echo "$LOCK_TIMEOUT" >"$timeoutfile"
    LOCK_ACQUIRED=1
    return 0
}

release_lock() {
    [ "$LOCK_ACQUIRED" -eq 1 ] && rm -rf "${LOCKFILE}.d"
}

record_state() {
    local state_file="$1"
    local hash="$2"
    mkdir -p "$STATE_DIR"
    local temp
    temp=$(mktemp "$STATE_DIR/.state.XXXXXX")
    echo "$hash" > "$temp"
    mv "$temp" "$state_file"
}

cleanup_and_exit() {
    release_lock
    exit 130
}

trap release_lock EXIT
trap cleanup_and_exit INT TERM

COLOR_ENABLED=${COLOR_ENABLED:-true}
LOGGING_NO_PREFIX=${LOGGING_NO_PREFIX:-0}
REPO_ROOT="$(git rev-parse --show-toplevel)"
source "$REPO_ROOT/lib/lib.sh"

log_to_system "info" "Activation started by $USER (timeout: ${LOCK_TIMEOUT}m, cores: ${MAX_CORES})"

if ! acquire_lock; then
    log_to_system "error" "Failed to acquire lock, aborting activation"
    exit 1
fi

log_to_system "info" "Lock acquired successfully"

if [ "$(uname -s)" = "Darwin" ]; then
    curl --proto '=https' --tlsv1.2 -sSf -L https://github.com/NixOS/nix/raw/master/scripts/sequoia-nixbld-user-migration.sh | bash - >/dev/null 2>&1 || true
fi

if [ -e "/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh" ]; then
    . "/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh"
fi
if [ -e "$HOME/.nix-profile/etc/profile.d/nix.sh" ]; then
    . "$HOME/.nix-profile/etc/profile.d/nix.sh"
fi

for cmd in git nix; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
        log_error "Required command '$cmd' not found."
        log_error "Please ensure git and nix are installed and in your PATH."
        exit 1
    fi
done

OS=$(uname -s)
ARCH=$(uname -m)
TARGET_HASH=$(git -C "$REPO_ROOT" rev-parse HEAD)

case "$OS" in
    "Darwin")
        if ! is_activated "$SYSTEM_STATE" "$TARGET_HASH"; then
            REBUILD_CMD="darwin-rebuild"
            command -v darwin-rebuild >/dev/null 2>&1 || {
                log_to_system "info" "Installing nix-darwin..."
                REBUILD_CMD="nix run nix-darwin/master#darwin-rebuild --"
            }
            command -v darwin-rebuild >/dev/null 2>&1 && log_to_system "info" "Updating nix-darwin configuration..."
            run_logged "darwin-rebuild" "$COLOR_WHITE" sudo NIX_CONFIG="$NIX_CONFIG" $REBUILD_CMD switch --flake "$REPO_ROOT" --max-jobs "$MAX_CORES" --cores "$MAX_CORES" \
                && record_state "$SYSTEM_STATE" "$TARGET_HASH" || exit 1
        fi
        HOME_MANAGER_TARGET="moye-aarch64-darwin"
        ;;
    "Linux")
        if [ -f /etc/NIXOS ] && ! is_activated "$SYSTEM_STATE" "$TARGET_HASH"; then
            log_to_system "info" "Updating NixOS configuration..."
            run_logged "nixos-rebuild" "$COLOR_WHITE" sudo nixos-rebuild switch --flake "$REPO_ROOT" --max-jobs "$MAX_CORES" --cores "$MAX_CORES" \
                && record_state "$SYSTEM_STATE" "$TARGET_HASH" || exit 1
        fi

        case "$ARCH" in
            "aarch64" | "arm64") HOME_MANAGER_TARGET="moye-aarch64-linux" ;;
            "x86_64") HOME_MANAGER_TARGET="moye-x86_64-linux" ;;
            *)
                log_error "Unsupported Linux architecture '$ARCH'"
                exit 1
                ;;
        esac
        ;;
    *)
        log_error "Unsupported operating system '$OS'"
        exit 1
        ;;
esac

is_activated "$HOME_STATE" "$TARGET_HASH" || {
    run_logged "home-manager" "$COLOR_WHITE" nix shell nixpkgs#home-manager -c home-manager switch -b backup --flake "$REPO_ROOT#$HOME_MANAGER_TARGET" \
        && record_state "$HOME_STATE" "$TARGET_HASH" || exit 1
}

log_to_system "info" "Configuration updated successfully"
