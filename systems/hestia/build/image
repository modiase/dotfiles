import os
import re
import subprocess
import sys
import platform
from dataclasses import dataclass
from pathlib import Path

import click
import inquirer
from loguru import logger

# Imports from build_utils package
from pyutils import (
    build_nix_image,
    check_nix,
    check_ssh_access,
    copy_to_clipboard,
    run_command_env_context,
    setup_logging,
)


@dataclass
class ImageInfo:
    path: Path
    compressed_bytes: int
    decompressed_bytes: int

    @property
    def compressed_human(self) -> str:
        return _format_bytes(self.compressed_bytes)

    @property
    def decompressed_human(self) -> str:
        return _format_bytes(self.decompressed_bytes)


def _run_cmd(cmd: list[str], remote_host: str | None = None) -> subprocess.CompletedProcess:
    """Run command locally or via SSH."""
    if remote_host:
        return subprocess.run(
            ["ssh", f"moye@{remote_host}"] + cmd, capture_output=True, text=True
        )
    return subprocess.run(cmd, capture_output=True, text=True)


def _format_bytes(n: int) -> str:
    """Format bytes as human-readable size."""
    for unit in ["B", "KiB", "MiB", "GiB"]:
        if n < 1024:
            return f"{n:.1f} {unit}"
        n /= 1024
    return f"{n:.1f} TiB"


def _parse_zstd_sizes(output: str, filename: str) -> tuple[int, int]:
    """Parse compressed and decompressed sizes from zstd -l output."""
    multipliers = {"B": 1, "KiB": 1024, "MiB": 1024**2, "GiB": 1024**3}
    size_pattern = r"(\d+\.?\d*)\s*(GiB|MiB|KiB|B)"

    for line in output.split("\n"):
        if filename not in line or "Frames" in line:
            continue
        matches = re.findall(size_pattern, line)
        if len(matches) >= 2:
            compressed = int(float(matches[0][0]) * multipliers[matches[0][1]])
            decompressed = int(float(matches[1][0]) * multipliers[matches[1][1]])
            return compressed, decompressed

    raise ValueError(f"Could not parse sizes from zstd output: {output}")


def discover_image(build_output: Path, remote_host: str | None = None) -> ImageInfo:
    """Find the .img.zst file and get its size information."""
    result = _run_cmd(
        ["find", str(build_output), "-name", "*.img.zst", "-type", "f"], remote_host
    )
    files = [f for f in result.stdout.strip().split("\n") if f]
    if len(files) != 1:
        raise ValueError(f"Expected one .img.zst in {build_output}, found: {files}")

    image_path = Path(files[0])
    result = _run_cmd(["zstd", "-l", str(image_path)], remote_host)
    compressed, decompressed = _parse_zstd_sizes(result.stdout, image_path.name)

    return ImageInfo(path=image_path, compressed_bytes=compressed, decompressed_bytes=decompressed)


def get_flash_instructions(image: ImageInfo, remote_host: str | None = None) -> str:
    if remote_host:
        return f"ssh moye@{remote_host} 'zstd -d -c {image.path}' | sudo dd of=/dev/sdX bs=4M status=progress"
    return f"zstd -d -c {image.path} | sudo dd of=/dev/sdX bs=4M status=progress"


def _check_removable_darwin(device_path: str) -> bool:
    result = subprocess.run(
        ["diskutil", "list", device_path], capture_output=True, text=True, check=False
    )
    return result.returncode == 0 and "(external, physical)" in result.stdout


def _check_removable_linux(device_path: str) -> bool:
    device_name = Path(device_path).name
    if device_name.startswith("sd"):
        removable_file = Path(f"/sys/block/{device_name}/removable")
        if removable_file.exists():
            return removable_file.read_text().strip() == "1"
    return False


def is_removable_device(device_path: str) -> bool:
    try:
        if platform.system() == "Darwin":
            return _check_removable_darwin(device_path)
        else:
            return _check_removable_linux(device_path)
    except Exception as e:
        logger.error(f"Failed to check if device is removable: {e}")
        return False


def validate_flash_device(device_path: str) -> bool:
    device = Path(device_path)

    if not device.exists():
        logger.error(f"Device does not exist: {device_path}")
        return False

    if not device.is_block_device():
        logger.error(f"Device is not a block device: {device_path}")
        return False

    if not is_removable_device(device_path):
        logger.error(f"Device is not removable/external: {device_path}")
        logger.error("For safety, only removable devices can be flashed automatically")
        return False

    logger.info(f"âœ“ Device {device_path} validated as removable/external")
    return True


def _run_disk_command(cmd: list, action: str) -> bool:
    result = subprocess.run(cmd, capture_output=True, text=True, check=False)
    if result.returncode == 0:
        logger.info(f"{action} successful")
        return True
    else:
        logger.warning(f"Failed to {action.lower()}: {result.stderr}")
        return False


def flash_image_to_device(
    image: ImageInfo,
    device_path: str,
    remote_host: str | None = None,
) -> bool:
    logger.warning(f"About to flash {image.path} to {device_path}")
    logger.warning("This will DESTROY ALL DATA on the target device!")

    try:
        logger.info("Unmounting device before flashing...")
        if platform.system() == "Darwin":
            _run_disk_command(["diskutil", "unmountDisk", device_path], "Unmount")
        else:
            _run_disk_command(["sudo", "umount", f"{device_path}*"], "Unmount")

        logger.info("Starting flash process...")
        if remote_host:
            flash_cmd = f"ssh moye@{remote_host} 'zstd -d -c {image.path}' | pv -s {image.decompressed_bytes} | sudo dd of={device_path} bs=4M"
        else:
            flash_cmd = f"zstd -d -c {image.path} | pv -s {image.decompressed_bytes} | sudo dd of={device_path} bs=4M"
        result = subprocess.run(flash_cmd, shell=True, check=False, text=True)

        if result.returncode == 0:
            logger.success(f"Successfully flashed {image.path} to {device_path}")

            logger.info("Ejecting device...")
            if platform.system() == "Darwin":
                _run_disk_command(["diskutil", "eject", device_path], "Device eject")
            else:
                _run_disk_command(["sudo", "eject", device_path], "Device eject")

            return True
        else:
            logger.error(f"Flash failed with exit code {result.returncode}")
            return False

    except Exception as e:
        logger.error(f"Flash failed with exception: {e}")
        return False


def perform_hestia_dry_run(repo_root: Path, remote_host: str) -> bool:
    logger.info("Performing hestia dry run checks")

    checks = [
        (
            "Nix flake",
            lambda: check_nix(
                repo_root, "nixosConfigurations.hestia.config.system.build.sdImage"
            ),
        ),
        ("SSH access", lambda: check_ssh_access(remote_host)),
    ]

    all_passed = True

    for check_name, check_func in checks:
        try:
            if not check_func():
                all_passed = False
        except Exception as e:
            logger.error(f"Check '{check_name}' failed with exception: {e}")
            all_passed = False

    if all_passed:
        logger.success("All hestia dry run checks passed")
    else:
        logger.error("Some hestia dry run checks failed")

    return all_passed


@click.command()
@click.option(
    "-v", "--verbose", count=True, help="Increase verbosity (use multiple times)"
)
@click.option(
    "--project-id", default="modiase-infra", envvar="PROJECT_ID", help="GCP project ID"
)
@click.option(
    "--remote-host", default="herakles", envvar="REMOTE_HOST", help="Remote build host"
)
@click.option("--interactive", is_flag=True, help="Interactive mode with prompts")
@click.option("--verify", is_flag=True, help="Check all prerequisites without building")
@click.option(
    "-d",
    "--device",
    help="Device to flash image to (e.g., /dev/disk2). Must be removable/external.",
)
def cli(
    verbose: int,
    project_id: str,
    remote_host: str,
    interactive: bool,
    verify: bool,
    device: str,
):
    setup_logging(verbose)

    repo_root = Path(
        os.environ.get("REPO_ROOT", Path(__file__).parent.resolve().parent)
    )

    if device:
        logger.info(f"Validating specified device {device}")
        if not validate_flash_device(device):
            logger.error(f"Device validation failed for {device}")
            logger.error("Fix the device issue before proceeding with build")
            sys.exit(1)
        logger.info(f"Device {device} validated successfully")

    with run_command_env_context(
        CI="1", TERM="dumb", NO_COLOR=os.environ.get("NO_COLOR", "false")
    ):
        if verify:
            with logger.contextualize(task="checking-prerequisites"):
                logger.info("Running hestia dry run checks")
                sys.exit(0 if perform_hestia_dry_run(repo_root, remote_host) else 1)

    action = "build"
    copy_command = False

    if interactive:
        questions = [
            inquirer.List(
                "action",
                message="What would you like to do?",
                choices=[
                    ("Build hestia image", "build"),
                    ("Verify (check only)", "verify"),
                ],
            )
        ]

        if verbose == 0:
            questions.append(
                inquirer.List(
                    "verbosity",
                    message="Select verbosity level:",
                    choices=[("Normal", 0), ("Debug", 1), ("Trace", 2)],
                )
            )

        answers = inquirer.prompt(questions)
        action = answers["action"]

        if "verbosity" in answers:
            verbose = answers["verbosity"]
            setup_logging(verbose)

    if action == "verify":
        with logger.contextualize(task="checking-prerequisites"):
            sys.exit(0 if perform_hestia_dry_run(repo_root, remote_host) else 1)

    if action != "build":
        logger.info("Build cancelled")
        return

    with logger.contextualize(task="building-image"):
        logger.info("Building hestia image")
        build_output = Path(
            build_nix_image(
                repo_root,
                "nixosConfigurations.hestia.config.system.build.sdImage",
                "aarch64-linux",
                remote_host,
                ["--verbose"] if verbose >= 2 else None,
            )
        )
        try:
            image = discover_image(build_output, remote_host)
        except ValueError as e:
            logger.error(str(e))
            sys.exit(1)

    logger.success("Hestia image built successfully")
    logger.info(f"Image: {image.path}")
    logger.info(f"Size: {image.compressed_human} compressed, {image.decompressed_human} decompressed")

    if device:
        with logger.contextualize(task="flashing-device"):
            if flash_image_to_device(image, device, remote_host):
                logger.success(f"Image successfully flashed to {device}")
                return
            logger.error(f"Failed to flash image to {device}")
            sys.exit(1)

    logger.info(f"Flash with: {get_flash_instructions(image, remote_host)}")

    if interactive:
        copy_answers = inquirer.prompt(
            [inquirer.Confirm("copy_command", message="Copy flash command to clipboard?", default=False)]
        )
        if copy_answers and copy_answers["copy_command"]:
            if copy_to_clipboard(get_flash_instructions(image, remote_host)):
                logger.info("Flash command copied to clipboard!")
            else:
                logger.warning("Could not copy to clipboard")


if __name__ == "__main__":
    cli()
